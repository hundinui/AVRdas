// AVRdas
//
// TODO:
// - test more and find bugs
// - implement the (temporarily gutted) assembler and emulator portions
// - documentation and clean up ugly code
// - rewrite the preprocessor, what was i thinking (aka clean up ugly code)) )

#define COUNT_TIME_TAKEN	// undefine to not count time

#include "common.h"
#include "avrasm.h"
#include "preprocessor.h"
#include "defstorage.h"
#include "ihex.h"
#include "disasm_instructions.h"

#ifdef COUNT_TIME_TAKEN
#include <time.h>
#endif

#define VERSION "0.9"

const char *text_title =
"AVR disassembler"
"\n"
"Licenced under the GNU GPLv3\n"
"Version: " VERSION " (Build " __DATE__ " " __TIME__ ")"
"\n";

const char *text_help =
"write help here\n"
"\tmake sure the input file to work on is last argument\n";

const char *text_options =
"Usage: %s [options] file\n"
//"\t-d        - Disassembly mode\n"
//"\t-a        - Assembly mode\n"
"\t-o file	- Output file (default: stdout)\n"
"\t-h	- Help text\n"
//"\t-I dir	- Add include directory\n"
//"\t-s - simulate\n"
//"\tAssembly options:\n"
//"\t-l file	- Generate list file\n"
"\tDisassembly options:\n"
"\t-A	- Prefix instructions by their address and opcode in hex\n"
"\t-D file	- Device definition file\n\n";

const char *header_text =
"; File generated by AVRdas version " VERSION "\n"
"; Input file: '%s'\n"
"; Using define file: '%s'\n\n";

int main(int argc, char *argv[]) {

#ifdef COUNT_TIME_TAKEN
	clock_t time_start, time_end;
	time_start = clock();
#endif

	printf("%s", text_title);
	// command line stuff
	char *output = NULL;
	char *filename = NULL;
	char *definefilename = NULL;
	prefixInstruction = false;

	if (argc < 3) {
		printf(text_options, argv[0]);
		//printf(text_help);
		printf("ERROR: Too few arguments to work with!\n");
		return 1;
	}

	for (int i = 1; i < (argc - 1); i++) {
		switch (argv[i][1]) {
		case 'o':
			output = strcmp(argv[i], "-o") ? NULL : argv[++i];
			break;
		case 'h':
			if(strcmp(argv[i], "-h")) printf("%s", text_help);
			break;
		case 'D':
			definefilename = strcmp(argv[i], "-D") ? NULL : argv[++i];
			break;
		case 'A':
			prefixInstruction = strcmp(argv[i], "-A") ? false : true;
			break;
		default:
			printf("ERROR: Unknown option %s\n", argv[i]);
			return 1;
			break;
		}
	}

	/* Set last arg as filename */
	filename = argv[argc - 1];

	int i = 0;
	if (output != NULL) {
		outputfile = fopen(output, "w");
		if (outputfile == NULL) {
			printf("ERROR: Error opening output file '%s'!\n", output);
			return 1;
		}
	}
	else {
		outputfile = stdout;
	}

	char readbuf[1024];

	if (load_file(filename) == 1) {
		printf("ERROR: Error opening input file '%s'!\n", filename);
		return 1;
	}
	i = 0;

	/* Definitions file pass */
	if (definefilename != NULL) {
		ppStoreInit();
		FILE *definefile = fopen(definefilename, "r");
		if (definefile == NULL) {
			printf("ERROR: Error opening definition file '%s'!\n", definefilename);
			return 1;
		}
		hasDefinitions = true;
		while (1) { // First pass
			++i;
			if (fgets(readbuf, 1024, definefile) != NULL) {
				ppCleanLine(readbuf, i, 1);
				//printf("%s\n", readbuf);
			}
			else {
				break;
			}
		}
		//ppStorePrint();
	}
	else {
		definefilename = "None";
	}

	/*
	 * There used to be a second pass that searched for
	 * comparisons done on ZH/ZL registers, but it was broken
	 * in all but the first test case so no point in keeping it
	 */

	fprintf(outputfile, header_text, filename, definefilename);
	zsearch = ZSEARCH_NONE;
	bool isEmptySpace = false;
	resetJumpDone = 0;
	fprintf(outputfile, ".org 0x0000\n");
	i = 0;
	while (i <= maxaddr) { // THIRD PASS
			if (i == resetJumpDone && i != 0) {
				printf("\nRESET:\n");
			}
			unsigned short op = (memory[i + 1] << 8) | (memory[i]);
			unsigned short op2 = (memory[i + 3] << 8) | (memory[i + 2]);
			if (op != '\0') {
				/* If just a bunch of zeros then no point in having that as a bunch of defined bytes */
				if (isEmptySpace == true) {
					isEmptySpace = false;
					fprintf(outputfile, ".org 0x%04X\n", i / 2);
				}
				//printf("%04X:", i / 2);
				if (!disasm_opcode(op, op2, i)) {
					i += 2;
				}
				else {
					i += 4;
				}
			}
			else {
				isEmptySpace = true;
				i += 2;
			}
		}
	//ppStorePrint();
	printf("\nDisassembly finished!\n");

#ifdef COUNT_TIME_TAKEN
	time_end = clock();
	printf("Took %f seconds\n", (double)(time_end - time_start) / CLOCKS_PER_SEC);
#endif
	return 0;
}
